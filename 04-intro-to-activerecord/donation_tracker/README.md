# Intro to Active Record

### Lecture Objectives

- Demonstrate how to use rake and Active Record to build classes, instances, and tables using a One to Many relationship
- Demonstrate the benefits of an ORM
- Demonstrate how to use Active Record to query a database
- Demonstrate how Active Record uses SQL

### Lecture Take Aways

- Active Record
- Inheritance
- Rake
- Migrations
- Seeds
- Active Record Queries

# What is Active Record?

```txt
"Active Record is the M in MVC - the model - which is the layer of the system responsible for representing business data and logic. Active Record facilitates the creation and use of business objects whose data requires persistent storage to a database. It is an implementation of the Active Record pattern which itself is a description of an Object Relational Mapping system."

- Ruby on Rails Guides
```

- A gem that can be installed and used with a Ruby application
- It is an ORM
- A tool used to bind our Ruby applications with our databases to perform CRUD actions on each object
- Convention over configuration!

### Important folders and files to pay attention to:
- App folder: This folder will contain the MVC: Model, View and Controller components of our application. 
- Config/environment.rb file will be responsible for also establishing a connection with Active Record and database.
- Db folder will be important for information regarding database and tables. Inside this folder there will be a migrate folder which will contain each generated migration file. Once a table has been migrated, a schema file will be produced which can be used as a point of reference for database structure. Seeds files can also be found here, these are used to define mass amounts of data that will be persisted to database. 
- Rakefile will be used to add or import any rake tasks

### MVC 

- Model, View and Controller
- A pattern used to organize code and separate by responsibilities 
- Model: Responsible for shaping and working with data and business logic, connected to the database.
- View: The client side of the application. The interface users will interact with. Data representation part of the application. 
- Controller: The brains of the application that will draw a bridge across the model and views. The controller is responsible for receiving and handling requests a user will make. The controller will tell the model what to do and then communicate that data to the view. 

IMPORTANT: A model and view should never directly communicate. Views should never directly communicate with databases. 

# Configuring a project to use Active Record

1. Install the active record gem: `gem install activerecord` or add gem to Gemfile.
2. Connect Active Record to database so that it knows which database to perform methods on:
3. Create a file `database.yml` inside the `config` folder with the following code:

```rb
development:
  adapter: sqlite3
  database: db/development.sqlite3
```
4. Update the `config/environment.rb` file to:
```rb
ENV["RACK_ENV"] ||= "development"

require 'bundler/setup'
Bundler.require(:default, ENV["RACK_ENV"])

require_all "app"
```
3. Link model to Active Record by using 'class inheritance'. This will inherit all the methods defined in the Active Record Base library and allow the class to utilize them. Create a file `application_record.rb` and add the following code:

```rb
class ApplicationRecord < ActiveRecord::Base
end
```

# Rake

- Rake is a gem that can be installed and used to automate repetitive behaviors and actions
- These defined actions are called Rake tasks and will be defined inside the `Rakefile` 
- To see a list of defined rake tasks run the following command: ` rake -T `
- To define a new rake task: 
```rb
task :task_name do
  # task logic
end
```
- Execute the following command: `rake task_name` to invoke a rake task

Add the following code to `Rakefile`

```rb
require_relative './config/environment'
require 'sinatra/activerecord/rake'

desc "Runs a Pry console"
task :console do
  # This line turns on logging of the SQL generated by Active Record
  ActiveRecord::Base.logger = Logger.new(STDOUT)
  
  # Open a Pry session
  Pry.start
end
```

### Creating tables

Now that Active Record is configured and the models have been defined, tables can be created
Note: Creating models before creating tables is not necessary when configuring a project, but it is best practice to follow this pattern because the model will be necessary to communicate with the database.

Migration files are important for creating and modifying database tables.
1. Create a migration file responsible for creating a new table, run the following command in terminal: `rake db:create_migration NAME=create_table_name`
3. The new file will be created inside the `db/migrate` folder. Each one of these files in timestamped to ensure the correct order of execution.
4. Inside of the file, we will be using the `create_table` method to define a table
```rb 
  def change
    create_table :table_name do |t|
        # columns i.e:
        # t.string :name
    end
  end
```

Convention over configuration:
- Active Record is a conventional pattern that needs to be followed
- Class names are singular, table names are plural

# Seeds file

- This is a file that can be defined inside the `db` folder as `seeds.rb` 
- If `rake -T` is ran, the command `rake db:seeds` can be found. This is the command that will be used to execute the logic inside a seeds file. 
- A seeds file can be used to generate data in a simpler way.
- Can use Faker gem to generate fake data: [Faker Gem Documentation](https://github.com/faker-ruby/faker)


# Lecture Deliverables:

1. Configure the Donation Tracker app to integrate Active Record
2. Create a Rakefile with rake tasks imported from the `sinatra/activerecord/rake` library 
3. Create the donations and organizations table. In order to do so, a migrations file should be created first and then migrated. Donations table will have the following columns: amount:integer, date:datetime, :completed:boolean. Organizations will have a name:string column. 
4. Add the following seed data to the `seeds.rb` file:
```rb
feeding_america = Organization.create(name: 'Feeding America')
salvation_army = Organization.create(name: 'Salvation Army')
red_cross = Organization.create(name: 'American National Red Cross')

Donation.create(amount: 100.00, date: 10/12/21, completed: false)
Donation.create(amount: 500.00, date: 10/15/21, completed: true)
Donation.create(amount: 20.00, date: 10/01/21, completed: false)
```
#### For the following exercises, think about where these methods should be defined by considering separation of responsibilities. These exercises will require usage of Active Record methods:
5. Use the .all method to query the donations class for all records
6. Utilize the find method to return a specific record given the id
7. Invoke the find_by method and return a donation record by a given amount
8. Create a new donation using the new method. Don't forget to persist this record
9. Create a new organizating using the create method. What is the difference between the new and create method?
10. Create a method that will return the total of all donations. 
- sum method for the total***
- donation model 

11. Create a method that will sort the list of existing organizations in alphabetical order.